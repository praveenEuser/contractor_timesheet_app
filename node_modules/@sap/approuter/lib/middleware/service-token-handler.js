/* eslint-disable camelcase */
'use strict';
const tokenUtils = require('../../lib/utils/token-utils');
const headerUtils = require('../../lib/utils/header-util');
const businessServiceUtils = require('../utils/business-service-utils');
const dynamicRoutingUtils = require('../utils/dynamic-routing-utils');
const jwtDecode = require('jwt-decode');
const sessionExt = require('../utils/session-ext');
const {getExpiresAt: expiresAt} = require('../passport/utils');
const {promisify} = require('util');

module.exports = {
  replaceUserToken: async function (req, session, serviceTag, ignoreDots) {
    session = session || req.session;
    const correlationId = headerUtils.getCorrelationId(req);

    if (!session){
      throw new Error('Missing session for replace user token');
    }
    if (session.user.businessServices && serviceTag && session.user.businessServices[serviceTag] && session.user.businessServices[serviceTag].expireDate > Date.now()) {
      return session.user.businessServices[serviceTag].accessToken;
    }
    const externalServiceCredentials = serviceTag ? businessServiceUtils.getCredentials(serviceTag, ignoreDots, req) : req.internalUrl.route.credentials;
    const routerConfig = req ? req.routerConfig : null;
    if (routerConfig && routerConfig.getToken) {
      const getTokenProm = promisify(routerConfig.getToken.bind(routerConfig));
      const accessToken = await getTokenProm(req);
      const response = await tokenUtils.exchangeToken(accessToken, correlationId, externalServiceCredentials.uaa);
      return response.accessToken;
    } else {
      if (!session.user.token){
        throw new Error('missing user token');
      }
      if (!externalServiceCredentials){
        throw new Error(`Missing credentials for service ${serviceTag}`);
      }
      const jwt = session.user.token.accessToken;
      if (externalServiceCredentials.forwardiasauthentication && session.user.token.authenticationType === 'ias') {
        return jwt;
      } else if (externalServiceCredentials.IASDependencyName && session.user.token.authenticationType === 'ias') {
        try {
          return await tokenUtils.getApp2AppToken(jwt,externalServiceCredentials, externalServiceCredentials.IASDependencyName, correlationId);
        } catch (err) {
          throw new Error(`Failed to get app2app token: ${err.message} for service ${serviceTag}`);
        }
      } else {
        const response = await tokenUtils.exchangeToken(jwt, correlationId, externalServiceCredentials.uaa);
        return response.accessToken;
      }
    }
  },
  isTokenExchangeRequired: function(req){
    return !!(req.internalUrl.route.service && req.internalUrl.route.credentials && businessServiceUtils.getGrantType(req.internalUrl.route.credentials) === 'user_token');
  },
  shouldAskBusinessToken: async function(req, serviceTag){
    if (process.env.NODE_ENV === 'development') {
      return !!req.session;
    }
    if (!req.session || !req.session.user){
      throw new Error('Route with service needs oauth authentication');
    }
    return !req.session.user.businessServices || !req.session.user.businessServices[serviceTag] || req.session.user.businessServices[serviceTag].expireDate < Date.now();
  },
  setTokenInUserSession: async function (req, token, serviceTag) {
    let tokenDecoded = token.access_token ? token : jwtDecode(token);
    let accessToken  = token.access_token ? token.access_token : token;
    await new Promise((resolve, reject) => {
      sessionExt.update(req.session, function (session) {
        if (!session.user.businessServices) {
          session.user.businessServices = {};
        }
        session.user.businessServices[serviceTag] = {
          accessToken: accessToken,
          expireDate: expiresAt(tokenDecoded.exp - tokenDecoded.iat).getTime(),
          scope: tokenDecoded.scope
        };
      }, (err) => {
        if (err) {
          return reject(err); // Reject the Promise if an error occurs
        }
        resolve(); // Resolve the Promise when the callback completes
      });
    });
  },
  attachHeadersFromCredentials: function(req, serviceTag) {
    const existingHeaders = Object.keys(req.headers || []);
    const businessServiceCredentials = businessServiceUtils.getCredentials(serviceTag, false, req);

    for (const key in businessServiceCredentials) {
      if (key.toLowerCase().startsWith('url.headers')) {
        const headerKey = key.split('.')[2];
        if (headerKey && !existingHeaders.includes(headerKey)) {
          req.headers[headerKey] = businessServiceCredentials[key];
        }
      }
    }
  },
  getBoundServiceScopes: async function (req) {
    const session = req.session && req.session.user;
    if (!session) {
      return null;
    }
    const appKey = dynamicRoutingUtils.getApplicationKey(req);
    const serviceName = appKey && ((appKey.bsKey && appKey.bsKey.appPrefix) || appKey.appPrefix);
    if (!serviceName) {
      return null;
    }
    const externalServiceCredentials = businessServiceUtils.getCredentials(serviceName, true, req);
    if (!externalServiceCredentials) {
      return null;
    }
    const isUserTokenRequired = businessServiceUtils.getGrantType(externalServiceCredentials) === 'user_token';
    if (!isUserTokenRequired) {
      return null;
    }
    if (!session.businessServices || !session.businessServices[serviceName] || session.businessServices[serviceName].expireDate < Date.now()) {
      try {
        const token = await module.exports.replaceUserToken(req, req.session, serviceName, true);
        await module.exports.setTokenInUserSession(req, token, serviceName);
      } catch (err) {
        throw new Error(`Failed to replace user token: ${err.message} for service ${serviceName}`);
      }
    }
    const xsappname = externalServiceCredentials && externalServiceCredentials.uaa && externalServiceCredentials.uaa.xsappname;
    let scope = req.session.user.businessServices[serviceName].scope;
    scope = scope.map(s => {
      if (s.includes('.') && (s !== 'uaa.user')) {
        return `${xsappname}${s.substring(s.indexOf('.'))}`;
      }
      return s;
    });
    return scope;
  }
};
