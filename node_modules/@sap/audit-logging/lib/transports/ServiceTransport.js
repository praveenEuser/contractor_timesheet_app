'use strict';

var assert = require('assert');
var debug = require('debug')('audit/transport');
var fetchBase = require('node-fetch');
var fetch = require('fetch-retry')(fetchBase);
var util = require('util');
var http = require('http');
var https = require('https');
const { XsuaaService } = require('@sap/xssec');

function ServiceTransport(credentials, options, securityContext) {
  checkCredentials(credentials);
  this.subdomain = null;
  this.credentials = credentials;
  this.serviceURL = credentials.url + options.url;
  var requestAgentOptions = credentials.requestAgentOptions || {};
  debug('HTTP(S) Agent Options: %o', requestAgentOptions);
  var requestAgentClass = (this.serviceURL.startsWith('https')) ? https.Agent : http.Agent;
  this.requestAgent = new requestAgentClass(requestAgentOptions);
  this.appInfo = process.env.VCAP_APPLICATION ? JSON.parse(process.env.VCAP_APPLICATION) : {};
  this.securityContext = securityContext;
  if (this.credentials.uaa) {
    this.service = createAuthenticationService(this.credentials.uaa);
  }
}

ServiceTransport.prototype.log = function (message, callback) {
  var url = this.serviceURL + message._endpoint;
  var body = message._content;

  return this._doRequest(url, 'POST', body, callback);
};

ServiceTransport.prototype.updateConfigurationChange = function (id, state, callback) {
  this._updateState('configuration-changes/', id, state, callback);
};

ServiceTransport.prototype.updateDataModification = function (id, state, callback) {
  this._updateState('data-modifications/', id, state, callback);
};

ServiceTransport.prototype._updateState = function (subPath, id, state, callback) {
  var url = this.serviceURL + subPath + id;
  var body = {
    success: state
  };

  return this._doRequest(url, 'POST', body, callback);
};

ServiceTransport.prototype._doRequest = function (url, method, data, callback) {
  if (callback) {
    this._doRequestPromise(url, method, data)
      .then((result) => callback(null, result))
      .catch(callback);
  } else {
    return this._doRequestPromise(url, method, data);
  }
};

ServiceTransport.prototype.fetchWithRetry = async function(url, options) {
  const { retries, delay } = options;
  let lastError;
  for (let attempt = 1; attempt <= retries; attempt++) {
    const controller = new AbortController();
    const signal = controller.signal;
    options.signal = signal;
    setTimeout(() => {
      debug(`Attempt ${attempt}/${retries}: Request timed out after waiting for ${delay}ms.`);
      controller.abort();
    }, delay);

    try {
      debug(`Attempt ${attempt}/${retries}: Sending request to ${url}...`);

      const response = await fetch(url,options);

      if (response.ok) {
        debug(`Attempt ${attempt}/${retries}: Request succeeded with status ${response.status} (${response.statusText}).`);
      }
      return response;
    } catch (error) {
      lastError = error;
      if (error.name === 'AbortError') {
        debug(`Attempt ${attempt}/${retries}: Request was aborted due to timeout after waiting for ${delay}ms.`);
        lastError = new Error(`Request timed out after waiting for ${delay}ms.`);
      } else {
        debug(`Attempt ${attempt}/${retries}: An error occurred during request to ${url}. Error: ${error.message}. Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

  }

  throw new Error(`All retry attempts failed. Last error: ${lastError.message}`);
};


ServiceTransport.prototype._doRequestPromise = async function (url, method, data) {
  var headers = {
    'XS_AUDIT_APP': this.appInfo['application_name'],
    'XS_AUDIT_SPACE': this.appInfo['space_name'],
    'XS_AUDIT_ORG': this.appInfo['organization_name']
  };

  debug('Auditlog request: %s %s\n headers: %j\n body: %j',
    method, url, headers, data);

  return getAuthHeader.call(this)
    .then(async(header) => {
      headers['Content-Type'] = 'application/json;charset=UTF-8';
      headers['Authorization'] = header;

      const delay =  Number(process.env.REQ_DELAY) || 1000;
      const maxRetries = Number(process.env.REQ_RETRIES) || 5;

      const options = {
        method: method,
        retries: maxRetries,
        delay: delay,
        headers: headers,
        body: JSON.stringify(data),
        agent: this.requestAgent
      };

      return this.fetchWithRetry(url, options);
    })
    .then((res) => {
      debug('Auditlog response: status %s', res.status);
      var statusCode = res.status;

      return res.text()
        .then((body) => {
          try {
            body = JSON.parse(body);
          } catch (e) {
            body = null;
          }
          debug('Auditlog response: body %j', body);

          if (statusCode < 200 || statusCode >= 300) {
            var message = util.format('%s request to %s completed with status %d', method, url, statusCode);
            if (body) {
              var responseErr = body.error || body.errors || body;
              message += ': ' + JSON.stringify(responseErr);
            }

            throw new Error(message);
          }
          return body && body.id;
        });
    });
};

function getAuthHeader() {
  return new Promise((resolve, reject) => {
    if (this.credentials.user && this.credentials.password && this.credentials.url) {
      debug('Basic authentication: %s, %s, %s', this.credentials.user, this.credentials.password, this.credentials.url);
      return resolve('Basic ' + Buffer.from(this.credentials.user + ':' + this.credentials.password).toString('base64'));
    }
    else if (this.securityContext && this.securityContext.getGrantType() !== 'client_credentials') {
      const userToken = this.securityContext.getTokenInfo().getTokenValue();
      debug('User token exchange: %s, %s', this.securityContext.getGrantType(), userToken);
      this.service.fetchJwtBearerToken(userToken, getOptions(this.subdomain))
        .then((response) => {
          return resolve('Bearer ' + response.access_token);
        })
        .catch((err) => {
          return reject(err);
        });
    }
    else if (this.credentials.uaa && this.credentials.uaa.clientid
    && (this.credentials.uaa.clientsecret || (this.credentials.uaa.key && this.credentials.uaa.certificate))
    && this.credentials.uaa.url) {
      this.service.fetchClientCredentialsToken(getOptions(this.subdomain))
        .then((response) => {
          return resolve('Bearer ' + response.access_token);
        })
        .catch((err) => {
          return reject(err);
        });
    }
    else {
      return reject('No applicable authorization header method found.');
    }
  });
}

function checkCredentials(credentials) {
  assert(credentials, 'credentials should be provided!');
  assert(
    (credentials.user && credentials.password && credentials.url)
    || (credentials.url && credentials.uaa && credentials.uaa.clientid
    && (credentials.uaa.clientsecret || (credentials.uaa.key && credentials.uaa.certificate))
    && credentials.uaa.url),
    'credentials are missing information!');
}

function createAuthenticationService(config){
  const serviceConfiguration = {
    requests: {
      retry: true, //  take the default configuration for retries
    }
  };
  const credentials = config.credentials ? config.credentials : config;
  return new XsuaaService(credentials, serviceConfiguration);
}

function getOptions(subdomain) {
  return {
    tenant: subdomain,
    // eslint-disable-next-line camelcase
    token_format: 'jwt'
  };
}

module.exports = ServiceTransport;
