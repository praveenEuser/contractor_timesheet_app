const { inspect } = require('util')
const cds = require('@sap/cds')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx|sm')
const { fs, path } = cds.utils
const { token } = require('../../../lib/utils')
const maxRetries = cds.requires?.multitenancy?.serviceManager?.retries ?? 3

/* API */
class AbstractContainerManagerClient {

  constructor({clientid, clientsecret, url}) {
    this.clientid = clientid
    this.clientsecret = clientsecret
    this.url = url

    this.version = JSON.parse(fs.readFileSync(path.join(__dirname, '../../../package.json'), 'utf8')).version
    this.cachedToken = null
    this.sm_url = null
  }

  static SECRETS = /(passw)|(cert)|(ca)|(secret)|(key)|(access_token)|(imageUrl)/i

  create = () => {
    throw new Error('Method not implemented.')
  }

  get = async () => {
    throw new Error('Method not implemented.')
  }

  getAll = async () => {
    throw new Error('Method not implemented.')
  }

  acquire = async (tenant, parameters) => {
    try { return await this.get(tenant, { disableCache: true }) } catch (e) {
      if (e.status === 404) return this.create(tenant, parameters)
      throw e
    }
  }

  deploy = (container, tenant, out, options, deployEnv) => {
    return require('./hdi').deploy(container, tenant, out, options, deployEnv)
  }

  remove = async () => {
    throw new Error('Method not implemented.')
  }

  fetchResiliently = async (url, req, retriesLeft = maxRetries) => {
    req.method ??= 'GET'
    try {
      DEBUG?.('>', req.method.toUpperCase(), url, inspect({
        ...(req.headers && { headers: { ...req.headers, Authorization: req.headers.Authorization?.split(' ')[0] + ' ...' } }),
        ...(req.params && { params: req.params }),
        ...(req.data && { data: req.data })
      }, { depth: 11, compact: false, colors: cds.utils.colors.enabled }))
      let finalUrl = url
      if (req.params && Object.keys(req.params).length) {
        const query = Object.entries(req.params).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&')
        finalUrl += (url.includes('?') ? '&' : '?') + query
      }
      const body = req.data && !['GET', 'HEAD'].includes(req.method) ? JSON.stringify(req.data) : undefined
      const fetchOptions = { ...req, body }
      const res = await fetch(finalUrl, fetchOptions)
      const { status, statusText } = res
      const headers = Object.fromEntries(res.headers.entries())
      const contentType = res.headers.get('content-type') || ''
      const data = contentType.includes('application/json') ? await res.json() : await res.text()

      if (!res.ok) {
        let msg = [status, statusText, data?.message, typeof data?.error === 'object' ? JSON.stringify(data.error) : data?.error, data?.description, data?.cause].filter(Boolean).join(' – ')
        if (res.status === 429 && res.headers.get('retry-after')) msg += ` – retry after ${res.headers.get('retry-after')}`
        throw Object.assign(new Error(msg), { status, statusText, headers })
      }
      const response = { status, statusText, headers, data }
      DEBUG?.('<', req.method.toUpperCase(), url, status, statusText, inspect(AbstractContainerManagerClient._redacted(data), { depth: 11, colors: cds.utils.colors.enabled }))
      return response
    } catch (error) {
      const { status } = error ?? { status: 500 }
      if (status in { 400: 1, 401: 1, 403: 1, 404: 1, 429: 1, 409: 1 } || retriesLeft === 0) return Promise.reject(error)
      const attempt = maxRetries - retriesLeft + 1
      if (LOG._debug) {
        const e = error.toJSON?.() ?? error
        DEBUG(`fetching ${url} attempt ${attempt} failed with`, {
          ...(e.name && { name: e.name }),
          ...(e.message && { message: e.message }),
          ...(e.description && { description: e.description })
        })
      }
      let delay = 0
      // S-curve instead of exponential backoff to allow for high number of reattempts (∞)
      const maxDelay = 30000, midpoint = 6, steepness = 0.4
      delay = maxDelay * (1 + Math.tanh(steepness * (attempt - midpoint))) / 2
      await new Promise((resolve) => setTimeout(resolve, delay))
      if (req.headers?.Authorization) req.headers.Authorization = await this._token()
      return this.fetchResiliently(url, req, retriesLeft - 1)
    }
  }

  _token = async () => {
    if (this.cachedToken && this.cachedToken.expiry >= Date.now() + 30_000) {
      return `Bearer ${this.cachedToken.access_token}`
    }
    const raw = await token(this)
    const { access_token, expires_in } = JSON.parse(raw)
    this.cachedToken = { access_token, expiry: Date.now() + expires_in * 1000 }
    return `Bearer ${access_token}`
  }

  fetchApi = async (url, conf = {}) => {
    const { version } = JSON.parse(fs.readFileSync(path.join(__dirname, '../../../package.json'), 'utf8'))
    conf.headers ??= {}
    conf.headers.Authorization ??= await this._token()
    conf.headers['Accept'] ??= 'application/json'
    conf.headers['Content-Type'] ??= 'application/json'
    conf.headers['Client-ID'] ??= 'cap-mtx-sidecar'
    conf.headers['Client-Version'] ??= version
    conf.headers['X-CorrelationID'] ??= cds.context?.id
    conf.headers['X-Correlation-ID'] ??= cds.context?.id
    conf.baseURL ??= url.startsWith('http') ? '' : this.sm_url + '/v1/' // TODO skip fallback?
    return this.fetchResiliently(conf.baseURL + url, conf)
  }

  _poll = async (location, conf = {}) => {
    let attempts = 0, maxAttempts = 60, pollingTimeout = 3000, maxTime = pollingTimeout * maxAttempts / 1000
    const url = location.includes('/v1/') ? location.slice('/v1/'.length) : location
    const _next = async (resolve, reject) => {
      let response
      try {
        response = await this.fetchApi(url, conf)
      } catch (err) {
        return reject(err)
      }
      if (this._succeeded(response)) return resolve(response)
      if (this._failed(response)) return reject(this._pollError(response))
      if (attempts > maxAttempts) return reject(new Error(`Polling ${location} timed out after ${maxTime} seconds with state ${response.data?.state ?? 'unknown'}`))
      setTimeout(++attempts && _next, pollingTimeout, resolve, reject)
    }
    return new Promise(_next)
  }

  _succeeded = (response) => response.data?.state === 'succeeded'
  _failed = (response) => response.data?.state === 'failed'
  _pollError = (response) => response.data.errors[0] ?? response.data.errors

  static _errorMessage = (e, action, tenant) => {
    const msg = `Error ${action} tenant ${tenant}: ${e.response?.data?.error ?? e.code ?? e.message ?? 'unknown error'}`
    const cause = e.description || e.cause ? require('os').EOL + `Root Cause: ${e.description ?? e.cause}` : ''
    return msg + cause
  }

  /**
   * Masks password-like strings, also reducing clutter in output
   * @param {any} cred - object or array with credentials
   * @returns {any}
   */
  static _redacted = (cred) => {

    if (!cred) return cred
    if (Array.isArray(cred)) return cred.map(c => AbstractContainerManagerClient._redacted(c))
    if (typeof cred === 'object') {
      const newCred = Object.assign({}, cred)
      Object.keys(newCred).forEach(k => (typeof newCred[k] === 'string' && AbstractContainerManagerClient.SECRETS.test(k)) ? (newCred[k] = '...') : (newCred[k] = AbstractContainerManagerClient._redacted(newCred[k])))
      return newCred
    }
    return cred
  }

}

module.exports = AbstractContainerManagerClient