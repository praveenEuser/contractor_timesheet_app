const crypto = require('crypto')
const AbstractContainerManagerClient = require('./ctnr-mgr-base')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx|tms')

/**
 * TMSClient class for managing HANA tenants and containers.
 *
 * Missing
 * - handling of UPDATE_SUCCEEDED, UPDATE_IN_PROGRESS, UPDATE_FAILED
 * - evaluation of database_id
 * - encryption parameters?
 * - support of get all
 *
 */

class TMSClient extends AbstractContainerManagerClient {
  constructor(credentials) {
    super(credentials.uaa)
    this.tmsHost = credentials.baseurl

    //this.hanaTenantPrefix = `${encodeURIComponent(credentials.uaa.xsappname)}-` // TODO not nice, find something better that is unique to for the application instance as fallback

    this.credentialCache = {}
  }

  static newInstance(credentials) {
    return new TMSClient(credentials)
  }

  // Generate hana-tenant-id as a hash of hana-tenant-name
  // only to avoid collisions
  // not expected to be true later due to potential changes caused by backup/restore etc
  static generateTenantId(hanaTenantName) {
    const hash = crypto.createHash('sha256').update(hanaTenantName).digest('hex')
    return [hash.slice(0, 8), hash.slice(8, 12), hash.slice(12, 16), hash.slice(16, 20), hash.slice(20, 32)].join('-')
  }

  // Helper method to find valid credentials from a list
  static _findValidCredentials(credentialList) {
    if (!Array.isArray(credentialList)) {
      return null
    }

    // Filter credentials with 'CREATE_SUCCEEDED' or 'CREATE_IN_PROGRESS' state
    const validCredentials = credentialList.filter(({ state }) => state === 'CREATE_SUCCEEDED' || state === 'CREATE_IN_PROGRESS')

    if (validCredentials.length === 0) {
      return null
    }

    // Sort by createTimestamp (newest first) and return the most recent one
    const sorted = validCredentials.sort((a, b) => {
      return new Date(b.createTimestamp) - new Date(a.createTimestamp)
    })
    const succeeded = sorted.find(c => c.state === 'CREATE_SUCCEEDED')
    if (succeeded) return succeeded
    return sorted[0]
  }

  // Find container and credentials, return {container, credentials, eTag}
  async findContainerAndCredentials(hanaTenantId, btpTenantName) {
    const response = await this.fetchApi(`/tenants/v2/tenants/${hanaTenantId}/containers?$expand=credentials`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404) throw new Error('404')
    const data = await response.data
    const container = data.data.find(entry =>
      Array.isArray(entry.labels) &&
      entry.labels.includes(`tenant_id=${btpTenantName}`)
    )
    const credentials = TMSClient._findValidCredentials(container?.credentials)
    const eTag = response.headers['etag']
    return { container, credentials, eTag }
  }

  async findHanaTenantContainerAndCredentials(btpTenantName) { // TODO expanding credentials does not work currently?
    const response = await this.fetchApi(`/tenants/v2/tenants?containerFilter=hassubset(labels,["tenant_id=${btpTenantName}"])&$expand=containers`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404) throw new Error('404')
    const hanatenant = response.data?.data[0]
    if (!hanatenant?.containers) throw Object.assign(new Error(`No container found for tenant ${btpTenantName}`), { status: 404 })
    let eTag = response.headers['etag']
    let container = hanatenant.containers.find(entry =>
      Array.isArray(entry.labels) &&
      entry.labels.includes(`tenant_id=${btpTenantName}`)
    )
    // workaround section
    if (container) {
      ({ container, eTag } = await this.checkCreationStatus({ hanaTenantId: hanatenant.id, container, expand: true }))
    }
    // end workaround section
    // const credentials = container?.credentials // does not work currently
    const credentials = TMSClient._findValidCredentials(container?.credentials)
    return { hanatenant, container, credentials, eTag }
  }

  _hanaTenantLabel(hanaTenantName) {
    return hanaTenantName.length > 63 ? hanaTenantName.substring(0, 60) + '...' : hanaTenantName
  }

  async findHanaTenant(hanaTenantName) {
    const response = await this.fetchApi(`/tenants/v2/tenants?$filter=hassubset(labels,["hana_tenant_name=${this._hanaTenantLabel(hanaTenantName)}"])`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'GET'
    })
    if (response.status === 404 || !response.data?.data[0]) throw Object.assign(new Error(`No hana found for hana tenant name ${hanaTenantName}`), { status: 404 })
    const eTag = response.headers['etag']
    return { hanatenant: response.data?.data[0], eTag }
  }

  // Step: Create HANA tenant (PUT)
  async createHanaTenant(hanaTenantId, hanaTenantName, databaseId) {
    const response = await this.fetchApi(`/tenants/v2/tenants/${hanaTenantId}`, {
      baseURL: `https://${this.tmsHost}`,
      method: 'PUT',
      data: {
        serviceInstanceID: `${databaseId}`,
        labels: hanaTenantName ? [`hana_tenant_name=${this._hanaTenantLabel(hanaTenantName)}`] : []
      }
    })
    return response.headers['location']
  }

  // Check creation status
  // handles two variants: either location or existing ids
  checkCreationStatus = async ({ location, hanaTenantId, container, credentials, expand = false }) => {
    let url = location ? `https://${this.tmsHost}${location}` : `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}`
    if (!location) {
      if (credentials?.state === 'CREATE_SUCCEEDED') {
        return { credentials }
      }
      if (!credentials && !expand && container?.status?.state === 'CREATE_SUCCEEDED') {
        return { container }
      }
      if (container) url += `/containers/${container.id}`
      if (credentials) url += `/credentials/${credentials.id}`
    }
    const conf = expand ? { params: { $expand: !container ? 'containers/credentials' : 'credentials' } } : undefined
    const response = await this._poll(url, conf).catch(error => { throw error })
    const data = await response.data
    const eTag = response.headers['etag']
    return { container: container ? data : undefined, credentials: credentials ? data : undefined, data, eTag }
  }

  // poll helpers
  _succeeded = (response) => response.data?.state === 'CREATE_SUCCEEDED' || response.data?.status?.ready
  _failed = (response) => response.data?.state === 'CREATE_FAILED'
  _pollError = (response) => response

  async createContainer(hanaTenantId, btpTenantName, eTag) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers`
    const options = {
      method: 'POST',
      headers: {
        'if-match': eTag,
      },
      data: { type: 'hdi', labels: [`tenant_id=${btpTenantName}`] }
    }
    try {
      const response = await this.fetchApi(url, options)
      const location = response.headers['location']
      return { location }
    } catch (error) {
      if (error.status === 409) {
        const statusObj = await this.checkCreationStatus({ hanaTenantId, expand: true })
        if (statusObj.data?.containers?.length > 0) {
          const container = statusObj.data.containers.find(c => c.labels?.includes(`tenant_id=${btpTenantName}`))
          if (container) {
            const credentials = TMSClient._findValidCredentials(container.credentials)
            return { container, credentials }
          }
        }
        eTag = statusObj.eTag
        return this.createContainer(hanaTenantId, btpTenantName, eTag)
      } else {
        throw error
      }
    }
  }

  // TODO 409? -> not a problem if more than one valid credentials exist
  async createCredentials(hanaTenantId, containerId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}/credentials`
    const options = {
      method: 'POST',
      data: {},
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteCredentials(hanaTenantId, containerId, credentialsId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}/credentials/${credentialsId}`
    const options = {
      method: 'DELETE',
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteContainer(hanaTenantId, containerId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}/containers/${containerId}`
    const options = {
      method: 'DELETE'
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  async deleteHanaTenant(hanaTenantId) {
    const url = `https://${this.tmsHost}/tenants/v2/tenants/${hanaTenantId}`
    const options = {
      method: 'DELETE'
    }
    const response = await this.fetchApi(url, options)
    return response.headers['location']
  }

  get = async (tenant, options = { disableCache: false }) => {
    if (!tenant) throw new Error('Tenant name is required')
    if (options.disableCache || !this.credentialCache[tenant]) {
      if (!options.hana_tenant_name) options.hana_tenant_name = tenant
      const { container, credentials } = await this.findHanaTenantContainerAndCredentials(tenant)
      if (!container || !credentials || !container.status?.ready || credentials.state === 'DELETE_IN_PROGRESS') {
        DEBUG?.(`Container or credentials not found for tenant ${tenant} with hana_tenant_name ${options.hana_tenant_name}`)
        cds.error(`Tenant '${tenant}' does not exist`, { status: 404 })
      }
      this.credentialCache[tenant] = { credentials, tags: ['hana'] }
    }
    return this.credentialCache[tenant]
  }

  getAll = async (tenants, options) => {
    if (!tenants || tenants === '*') throw new Error('getAll for "*" not implemented for TMSv2.')
    const results = []
    for (const tenant of tenants) {
      const credentials = await this.get(tenant, options)
      if (credentials) {
        results.push({ tenant, credentials })
      }
    }
    return results
  }


  static _getHanaTenantId = (btpTenantName, options) => {
    let hanaTenantId = options.hana_tenant_id
    if (!hanaTenantId) {
      if (!options.hana_tenant_name) options.hana_tenant_name = (options.hana_tenant_prefix ?? this.hana_tenant_prefix ?? '') + btpTenantName // TODO use fallback this.hanaTenantPrefix here
      hanaTenantId = TMSClient.generateTenantId(options.hana_tenant_name)
    }
    return hanaTenantId
  }

  /**
   * Create a new HANA tenant and its HDI container with credentials
   */
  create = async (btpTenantName, parameters) => {
    const options = parameters?.provisioning_parameters || {}
    let hanaTenantId = TMSClient._getHanaTenantId(btpTenantName, options)
    let container, credentials, eTag
    try {
      ({ hanatenant: { id: hanaTenantId }, container, credentials, eTag } = await this.findHanaTenantContainerAndCredentials(btpTenantName)) // find by btpTenantName only - hanaTenantId is not guaranteed
      // If credentials are found and ready, return
      if (credentials) { // TODO await if not ready -> means to return incomplete credentials in previous call, as well
        return (await this.checkCreationStatus({hanaTenantId, container, credentials})).credentials
      }
    } catch (err) {
      if (err.status === 404) {
        // No HANA tenant found, create it
        // What about 409 -> not specified. Using PUT with generated id instead
        const location = await this.createHanaTenant(hanaTenantId, options.hana_tenant_name, options.database_id)
        // Wait until tenant is ready and extract eTag
        const response = await this.checkCreationStatus({ location })
        eTag = response.eTag
      } else throw err
    }

    if (!container) {
      const { location: containerLocation, container: newContainer } = await this.createContainer(hanaTenantId, btpTenantName, eTag)
      const response = await this.checkCreationStatus({ location: containerLocation, hanaTenantId, container: newContainer })
      container = response.container || response.data
    } else {
      ({ container } = await this.checkCreationStatus({ hanaTenantId, container, expand: true })) // TODO expand necessary here?
    }
    // check potentially existing credentials
    credentials = TMSClient._findValidCredentials(container?.credentials)
    let credentialsLocation
    if (!credentials) {
      credentialsLocation = await this.createCredentials(hanaTenantId, container.id)
    }
    const response = await this.checkCreationStatus({ location: credentialsLocation, hanaTenantId, container, credentials })
    credentials = response.credentials || response.data // TODO return credentials or data?
    this.credentialCache[btpTenantName] = { credentials, tags: ['hana'] }
    return this.credentialCache[btpTenantName]
  }

  remove = async (tenant, parameters) => {
    try {
      const { hanatenant: { id: hanaTenantId }, container } = await this.findHanaTenantContainerAndCredentials(tenant)
      if (!container) return
      // Delete credentials
      const credentials = container.credentials || []
      const deletions = credentials.map(async cred => {
        const location = await this.deleteCredentials(hanaTenantId, container.id, cred.id)
        try {
          await this.checkCreationStatus({ location })
        } catch (error) { // expect 404
          DEBUG?.(`Finished deleting credentials for tenant ${tenant}:`, error)
        }
      })
      await Promise.all(deletions)
      delete this.credentialCache[tenant]

      // Delete container
      const location = await this.deleteContainer(hanaTenantId, container.id)
      try {
        await this.checkCreationStatus({ location })
      } catch (error) { // expect 404
        if (error.status === 404) {
          DEBUG?.(`Finished deleting container for tenant ${tenant}:`, error)
        } else {
          LOG.error(`Error deleting container for tenant ${tenant}:`, error)
          throw error
        }
      }

      // Delete hana tenant if requested
      if (!parameters?.provisioning_parameters?.cleanup_hana_tenants) return
      const locationHanaTenant = await this.deleteHanaTenant(hanaTenantId)
      try {
        await this.checkCreationStatus({ location: locationHanaTenant })
      } catch (error) { // expect 404
        if (error.status === 404) {
          DEBUG?.(`Finished deleting hana tenant for tenant ${tenant}:`, error)
        } else {
          LOG.error(`Error deleting hana tenant for tenant ${tenant}:`, error)
          throw error
        }
      }
    } catch (error) {
      if (error.status === 404) {
        DEBUG?.(`Container for tenant ${tenant} not found, nothing to delete`)
      } else {
        LOG.error(`Error deleting container for tenant ${tenant}:`, error)
        throw error
      }
    }
  }

  delete = this.remove

}

module.exports = TMSClient
