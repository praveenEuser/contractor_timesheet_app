export = Jwk;
declare class Jwk {
    /**
     * Creates a JWK based on a PEM-formatted public key
     * @param {String} pem public key in PEM format
     * @returns Jwk
     */
    static fromPEM(pem: string): import("./Jwk");
    static mapAlgToNodeAlg(alg: any): "RSA-SHA256" | "RSA-SHA384" | "RSA-SHA512";
    static cleanUpPemKey(pem?: string): string;
    /**
     * Creates a JWK based on a jwk-formatted public key
     * @param {Object} key key information in jwk format
     */
    constructor(key: any);
    key: any;
    pubKey: crypto.KeyObject;
    nodeAlg: any;
    /**
     * Validates if the token was signed with the private key that belongs to this public key.
     * If available, uses the signature cache to avoid validating the same signature again on subsequent requests.
     * @param {Token} token
     * @param {import("../util/Types").Cache} [signatureCache] an optional cache for signature validation results
     * @returns void if the signature is valid
     * @throws {InvalidTokenSignatureError} when signature is invalid
     */
    validateSignature(token: Token, signatureCache?: import("../util/Types").Cache): void;
    /**
     * Validates if the token was signed with the private key that belongs to this public key without using a cache.
     * @param {Token} token
     * @returns {boolean} true if the signature is valid, false otherwise
     */
    validateSignatureWithoutCache(token: Token): boolean;
}
declare namespace Jwk {
    export { Token };
}
import crypto = require("crypto");
type Token = import("../token/Token");
//# sourceMappingURL=Jwk.d.ts.map